using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using Microsoft.Win32;
using iText.Kernel.Pdf;
using System.Windows.Media;
using ModernWpf.Controls;
using System.Windows.Shapes;
using Syncfusion.DocIO;
using Syncfusion.DocIO.DLS;
using Syncfusion.DocIORenderer;
using Syncfusion.Pdf;

namespace PDFSplitterforCopilot
{
    public partial class MainWindow : System.Windows.Window, INotifyPropertyChanged
    {
        private ObservableCollection<FileItem> fileItems = new ObservableCollection<FileItem>();
        
        // ëª¨ë“œë³„ í˜ì´ì§€ ìˆ˜ ê¸°ë³¸ê°’ ì €ì¥
        private int _splitModePageCount = 10;  // ë¶„í•  ëª¨ë“œ ê¸°ë³¸ê°’
        private int _convertModePageCount = 1; // ë³€í™˜ ëª¨ë“œ ê¸°ë³¸ê°’

        public bool HasFiles => fileItems.Count > 0;
        public bool NoFiles => fileItems.Count == 0;

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        
        public MainWindow()
        {
            InitializeComponent();
            
            // ìœˆë„ìš° í¬ê¸°ì™€ ìƒíƒœ ëª…ì‹œì  ì„¤ì • (ì „ì²´í™”ë©´ ë°©ì§€)
            this.WindowState = WindowState.Normal;
            this.Width = 900;
            this.Height = 600;
            this.MinWidth = 700;
            this.MinHeight = 500;
            this.WindowStartupLocation = WindowStartupLocation.CenterScreen;
            this.ResizeMode = ResizeMode.CanResize;
            
            dgFiles.ItemsSource = fileItems;
            DataContext = this;
            fileItems.CollectionChanged += (s, e) => 
            {
                OnPropertyChanged(nameof(HasFiles));
                OnPropertyChanged(nameof(NoFiles));
            };
            
            // ì´ˆê¸° ëª¨ë“œë³„ í˜ì´ì§€ ìˆ˜ ì„¤ì •
            InitializeModeSettings();
            
            // Event handlers are already set in XAML, removing redundant assignments
            // btnAddFiles.Click += BtnAddFiles_Click;
            // btnProcess.Click += BtnProcess_Click;
            // btnRemoveSelected.Click += BtnRemoveSelected_Click;
        }

        /// <summary>
        /// ëª¨ë“œë³„ ì´ˆê¸° ì„¤ì •ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
        /// </summary>
        private void InitializeModeSettings()
        {
            // ë¶„í•  ëª¨ë“œë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
            tbModeSwitch.IsChecked = false;
            numPageCount.Text = _splitModePageCount.ToString();
            
            // ì‹¤í–‰ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            UpdateProcessButtonText();
        }

        /// <summary>
        /// ì‹¤í–‰ ë²„íŠ¼ì˜ í…ìŠ¤íŠ¸ë¥¼ í˜„ì¬ ëª¨ë“œì— ë§ê²Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        /// </summary>
        private void UpdateProcessButtonText()
        {
            bool isConvertMode = tbModeSwitch.IsChecked == true;
            btnProcess.Content = isConvertMode ? "â–¶ ë³€í™˜ ì‹¤í–‰" : "â–¶ ë¶„í•  ì‹¤í–‰";
        }

        /// <summary>
        /// ìˆ«ì ì…ë ¥ë§Œ í—ˆìš©í•˜ëŠ” í…ìŠ¤íŠ¸ ì…ë ¥ ê²€ì¦
        /// </summary>
        private void NumPageCount_PreviewTextInput(object sender, System.Windows.Input.TextCompositionEventArgs e)
        {
            // ìˆ«ìë§Œ í—ˆìš© (0-9)
            e.Handled = !System.Text.RegularExpressions.Regex.IsMatch(e.Text, @"^[0-9]+$");
        }

        /// <summary>
        /// í˜ì´ì§€ ìˆ˜ í…ìŠ¤íŠ¸ ë³€ê²½ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        /// </summary>
        private void NumPageCount_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                // ë¹ˆ ë¬¸ìì—´ì´ê±°ë‚˜ 0ì¸ ê²½ìš° 1ë¡œ ì„¤ì •
                if (string.IsNullOrWhiteSpace(textBox.Text))
                {
                    textBox.Text = "1";
                    textBox.SelectionStart = textBox.Text.Length;
                }
                else if (int.TryParse(textBox.Text, out int value))
                {
                    // ë²”ìœ„ ì²´í¬ (1-50)
                    if (value < 1)
                    {
                        textBox.Text = "1";
                        textBox.SelectionStart = textBox.Text.Length;
                    }
                    else if (value > 50)
                    {
                        textBox.Text = "50";
                        textBox.SelectionStart = textBox.Text.Length;
                    }
                }
                else
                {
                    // ìˆ«ìê°€ ì•„ë‹Œ ê²½ìš° 1ë¡œ ì„¤ì •
                    textBox.Text = "1";
                    textBox.SelectionStart = textBox.Text.Length;
                }
            }
        }

        /// <summary>
        /// í˜„ì¬ í˜ì´ì§€ ìˆ˜ ê°’ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
        /// </summary>
        private int GetCurrentPageCount()
        {
            if (int.TryParse(numPageCount.Text, out int value) && value >= 1 && value <= 50)
            {
                return value;
            }
            return 1; // ê¸°ë³¸ê°’
        }

        private void CheckBox_Checked(object sender, RoutedEventArgs e)
        {
            // ì²´í¬ë°•ìŠ¤ê°€ ì„ íƒë˜ì—ˆì„ ë•Œì˜ ì²˜ë¦¬ (í•„ìš”ì‹œ)
        }

        private void CheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            // ì²´í¬ë°•ìŠ¤ê°€ í•´ì œë˜ì—ˆì„ ë•Œì˜ ì²˜ë¦¬ (í•„ìš”ì‹œ)
        }

        private void BtnRemoveSelected_Click(object sender, RoutedEventArgs e)
        {
            var selectedItems = fileItems.Where(f => f.IsSelected).ToList();
            
            foreach (var item in selectedItems)
            {
                fileItems.Remove(item);
            }
            
            txtStatus.Text = $"ì´ {fileItems.Count}ê°œ íŒŒì¼ ë“±ë¡ë¨";
            OnPropertyChanged(nameof(HasFiles));
            OnPropertyChanged(nameof(NoFiles));
        }

        public void Window_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                e.Effects = DragDropEffects.Copy;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        public async void Window_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
                await AddFilesToCollection(files);
            }
        }

        public async void BtnAddFiles_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog dialog = new OpenFileDialog
            {
                Multiselect = true,
                Filter = "PDF ë° Word íŒŒì¼|*.pdf;*.doc;*.docx|PDF íŒŒì¼|*.pdf|Word íŒŒì¼|*.doc;*.docx"
            };

            if (dialog.ShowDialog() == true)
            {
                await AddFilesToCollection(dialog.FileNames);
            }
        }
        
        private async System.Threading.Tasks.Task AddFilesToCollection(string[] filePaths)
        {
            txtStatus.Text = "íŒŒì¼ ê²€ì‚¬ ì¤‘...";
            
            foreach (string filePath in filePaths)
            {
                var fileItem = new FileItem
                {
                    FileName = System.IO.Path.GetFileName(filePath),
                    FilePath = filePath,
                    StatusColor = Brushes.Yellow,
                    StatusMessage = "ê²€ì‚¬ ì¤‘...",
                    PageCount = "ê²€ì‚¬ ì¤‘..."
                };

                fileItems.Add(fileItem);
                
                // íŒŒì¼ ê²€ì¦ì„ ë¹„ë™ê¸°ë¡œ ìˆ˜í–‰
                await ValidateFileAsync(fileItem);
            }
            
            txtStatus.Text = $"ì´ {fileItems.Count}ê°œ íŒŒì¼ ë“±ë¡ë¨";
            OnPropertyChanged(nameof(HasFiles));
            OnPropertyChanged(nameof(NoFiles));
            
            // Attach remove button event handlers for new items
            AttachRemoveButtonHandlers();
        }

        private void AttachRemoveButtonHandlers()
        {
            // This will be called whenever the DataGrid is updated
            // The actual event handler attachment happens through the XAML template
            // We'll handle this through the BtnRemove_Click method which gets the item from the button's Tag
        }

        private async System.Threading.Tasks.Task ValidateFileAsync(FileItem fileItem)
        {
            try
            {
                string extension = System.IO.Path.GetExtension(fileItem.FilePath).ToLower();
                
                if (extension == ".pdf")
                {
                    await ValidatePdfFileAsync(fileItem);
                }
                else if (extension == ".doc" || extension == ".docx")
                {
                    // Syncfusionì„ ì‚¬ìš©í•˜ë¯€ë¡œ MS Word ì„¤ì¹˜ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ë³€í™˜ ê°€ëŠ¥
                    fileItem.PageCount = "ë³€í™˜ í›„ í™•ì¸";
                    fileItem.StatusColor = Brushes.Orange;
                    fileItem.StatusMessage = "Wordâ†’PDF ë³€í™˜ í•„ìš”";
                }
                else
                {
                    fileItem.StatusColor = Brushes.Red;
                    fileItem.StatusMessage = "ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹";
                    fileItem.PageCount = "N/A";
                }
            }
            catch (Exception ex)
            {
                fileItem.StatusColor = Brushes.Red;
                fileItem.StatusMessage = $"ì˜¤ë¥˜: {ex.Message}";
                fileItem.PageCount = "N/A";
            }
        }

        private async System.Threading.Tasks.Task ValidatePdfFileAsync(FileItem fileItem)
        {
            await System.Threading.Tasks.Task.Run(() =>
            {                try
                {
                    var reader = new PdfReader(fileItem.FilePath);
                    using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                    {
                        int pageCount = pdfDoc.GetNumberOfPages();
                        // Calculate blank pages ratio
                        int blankCount = 0;
                        for (int i = 1; i <= pageCount; i++)
                        {
                            var page = pdfDoc.GetPage(i);
                            if (page.GetContentBytes().Length == 0)
                                blankCount++;
                        }
                        double blankRatio = blankCount / (double)pageCount;

                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.PageCount = pageCount.ToString();
                            fileItem.StatusColor = Brushes.Green;
                            fileItem.StatusMessage = "ì²˜ë¦¬ ê°€ëŠ¥";
                            fileItem.BlankPageRatio = blankRatio;
                        });
                    }
                }
                catch (iText.Kernel.Exceptions.BadPasswordException)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.StatusColor = Brushes.Red;
                        fileItem.StatusMessage = "ì•”í˜¸ê°€ í•„ìš”í•¨";
                        fileItem.PageCount = "N/A";
                    });
                }
                catch (Exception ex)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.StatusColor = Brushes.Red;
                        fileItem.StatusMessage = $"ì˜¤ë¥˜: {ex.Message}";
                        fileItem.PageCount = "N/A";
                    });
                }
            });        }
          public async void BtnProcess_Click(object sender, RoutedEventArgs e)
        {
            int pageSize = (int)numPageCount.Value;
            if (pageSize <= 0)
            {
                MessageBox.Show("ì˜¬ë°”ë¥¸ í˜ì´ì§€ ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", "ì˜¤ë¥˜");
                return;
            }

            // ëª¨ë“œ í™•ì¸ (ë¶„í•  ë˜ëŠ” ë³€í™˜) - í† ê¸€ ë²„íŠ¼ ê¸°ë°˜
            bool isConvertMode = tbModeSwitch.IsChecked == true;
            
            // ì²´í¬ëœ íŒŒì¼ë§Œ í•„í„°ë§
            var selectedFiles = fileItems.Where(f => f.IsSelected).ToList();
            if (!selectedFiles.Any())
            {
                MessageBox.Show("ì²˜ë¦¬í•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.", "ì•Œë¦¼");
                return;
            }

            // ì„ íƒëœ íŒŒì¼ ì¤‘ ìœ íš¨í•œ íŒŒì¼ë§Œ í•„í„°ë§ (OrangeëŠ” Word íŒŒì¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ ìƒíƒœ)
            var validFiles = selectedFiles.Where(f => f.StatusColor == Brushes.Green || f.StatusColor == Brushes.Orange).ToList();
            
            // ì²˜ë¦¬ ë¶ˆê°€ëŠ¥í•œ íŒŒì¼ë“¤ í™•ì¸ (Red ìƒíƒœ)
            var invalidFiles = selectedFiles.Where(f => f.StatusColor == Brushes.Red).ToList();
            
            if (invalidFiles.Any())
            {
                var result = MessageBox.Show(
                    $"ë‹¤ìŒ {invalidFiles.Count}ê°œì˜ íŒŒì¼ì€ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n\n" +
                    string.Join("\n", invalidFiles.Select(f => $"{f.FileName} - {f.StatusMessage}")) + "\n\n" +
                    "ì²˜ë¦¬ ê°€ëŠ¥í•œ íŒŒì¼ë§Œ ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                    "ì²˜ë¦¬ ë¶ˆê°€ íŒŒì¼ ì¡´ì¬", 
                    MessageBoxButton.YesNo, 
                    MessageBoxImage.Warning);
                    
                if (result == MessageBoxResult.No)
                {
                    return;
                }
            }
            
            if (!validFiles.Any())
            {
                MessageBox.Show("ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.", "ì•Œë¦¼");
                return;
            }

            // í™•ì¸ì°½ í‘œì‹œ (ëª¨ë“œì— ë”°ë¼ ë©”ì‹œì§€ ë³€ê²½)
            string modeText = isConvertMode ? "ë³€í™˜" : "ë¶„í• ";
            string detailText = isConvertMode ? 
                $"ê° íŒŒì¼ë‹¹ 1~{pageSize}í˜ì´ì§€ ì¶”ì¶œ" : 
                $"ë¶„í•  í˜ì´ì§€ ìˆ˜: {pageSize}í˜ì´ì§€";
                
            var confirmResult = MessageBox.Show(
                $"ì´ {validFiles.Count}ê°œì˜ íŒŒì¼ì„ {modeText}í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n{detailText}", 
                $"{modeText} í™•ì¸", 
                MessageBoxButton.YesNo, 
                MessageBoxImage.Question);

            if (confirmResult != MessageBoxResult.Yes)
            {
                return;
            }

            progressContainer.Visibility = Visibility.Visible;
            progressBar.Maximum = validFiles.Count;
            progressBar.Value = 0;

            btnProcess.IsEnabled = false;
            
            try
            {
                foreach (var fileItem in validFiles)
                {
                    txtStatus.Text = $"ì²˜ë¦¬ ì¤‘: {fileItem.FileName}";
                    
                    try
                    {
                        if (isConvertMode)
                        {
                            await ProcessConvertFileAsync(fileItem, pageSize);
                        }
                        else
                        {
                            await ProcessFileAsync(fileItem, pageSize);
                        }
                        LogMessage($"íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ: {fileItem.FileName}");
                    }
                    catch (Exception fileEx)
                    {
                        LogMessage($"íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: {fileItem.FileName}", fileEx, "ERROR");
                        
                        // ê°œë³„ íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸í•˜ê³  ê³„ì† ì§„í–‰
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.StatusColor = Brushes.Red;
                            fileItem.StatusMessage = $"ì²˜ë¦¬ ì‹¤íŒ¨: {fileEx.Message}";
                            if (fileItem.Steps != null && fileItem.Steps.Any())
                            {
                                var lastStep = fileItem.Steps.Last();
                                lastStep.Status = StepStatus.Error;
                                lastStep.Message = $"ì˜¤ë¥˜: {fileEx.Message}";
                            }
                        });
                        
                        // ì‚¬ìš©ìì—ê²Œ ê°œë³„ íŒŒì¼ ì˜¤ë¥˜ ì•Œë¦¼ (ì„ íƒ ì‚¬í•­)
                        var continueResult = MessageBox.Show(
                            $"íŒŒì¼ '{fileItem.FileName}' ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n\n{fileEx.Message}\n\në‹¤ìŒ íŒŒì¼ì„ ê³„ì† ì²˜ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                            "íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Warning);
                            
                        if (continueResult == MessageBoxResult.No)
                        {
                            break; // ì‚¬ìš©ìê°€ ì¤‘ë‹¨ì„ ì„ íƒí•˜ë©´ ë£¨í”„ ì¢…ë£Œ
                        }
                    }
                    
                    progressBar.Value++;
                }

                string completionMessage = isConvertMode ? 
                    $"ëª¨ë“  íŒŒì¼ ë³€í™˜ ì™„ë£Œ! ê° íŒŒì¼ë‹¹ 1~{pageSize}í˜ì´ì§€ê°€ ì¶”ì¶œë˜ì—ˆìŠµë‹ˆë‹¤." :
                    "ëª¨ë“  íŒŒì¼ ë¶„í•  ì™„ë£Œ!";
                    
                txtStatus.Text = completionMessage;
                MessageBox.Show(isConvertMode ? 
                    $"ë³€í™˜ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\nê° íŒŒì¼ë‹¹ 1~{pageSize}í˜ì´ì§€ê°€ ì¶”ì¶œë˜ì—ˆìŠµë‹ˆë‹¤." :
                    "ë¶„í•  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", 
                    "ì™„ë£Œ");
            }
            catch (Exception ex)
            {
                string detailedErrorMessage = $"ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{ex.GetType().FullName}: {ex.Message}\n\nStack Trace:\n{ex.StackTrace}";
                MessageBox.Show(detailedErrorMessage, "ì˜¤ë¥˜ ìƒì„¸ ì •ë³´");
                txtStatus.Text = "ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ";
            }
            finally
            {
                progressContainer.Visibility = Visibility.Collapsed;
                btnProcess.IsEnabled = true;
            }
        }

        private async System.Threading.Tasks.Task ProcessFileAsync(FileItem fileItem, int pageSize)
        {
            // ê³ ì •ëœ 5ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤
            int totalSteps = 5;
            
            // Initialize progress tracking
            Application.Current.Dispatcher.Invoke(() =>
            {
                fileItem.TotalSteps = totalSteps;
                fileItem.CurrentStep = 0;
                fileItem.StepMessage = "ì¤€ë¹„ ì¤‘...";
                
                // Initialize steps collection with 5 fixed steps
                fileItem.Steps.Clear();
                string[] stepNames = { "íŒŒì¼ ê²€ì¦", "ë¬¸ì„œ ì¤€ë¹„", "PDF ì½ê¸°", "ë¶„í•  ì²˜ë¦¬", "ì™„ë£Œ" };
                for (int i = 0; i < totalSteps; i++)
                {
                    fileItem.Steps.Add(new StepItem
                    {
                        Name = stepNames[i],
                        Status = StepStatus.Pending,
                        Message = "ëŒ€ê¸° ì¤‘..."
                    });
                }
            });            
            await System.Threading.Tasks.Task.Run(() =>
            {
                int currentStep = 0;
                string pdfPath = fileItem.FilePath;
                
                // Step 1: íŒŒì¼ ê²€ì¦
                Application.Current.Dispatcher.Invoke(() =>
                {
                    fileItem.UpdateStep(currentStep, "íŒŒì¼ í˜•ì‹ ê²€ì¦ ì¤‘...", StepStatus.InProgress);
                });
                
                try
                {
                    string extension = System.IO.Path.GetExtension(fileItem.FilePath).ToLower();
                    if (extension != ".pdf" && extension != ".doc" && extension != ".docx")
                    {
                        throw new NotSupportedException("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.");
                    }
                    
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, $"íŒŒì¼ ê²€ì¦ ì™„ë£Œ ({extension})", StepStatus.Completed);
                    });
                    currentStep++;
                    
                    // Step 2: ë¬¸ì„œ ì¤€ë¹„ (Word íŒŒì¼ì¸ ê²½ìš° PDFë¡œ ë³€í™˜)
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "ë¬¸ì„œ ì¤€ë¹„ ì¤‘...", StepStatus.InProgress);
                    });
                    
                    if (extension != ".pdf")
                    {
                        pdfPath = ConvertWordToPdfFile(fileItem.FilePath);
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, "Word â†’ PDF ë³€í™˜ ì™„ë£Œ", StepStatus.Completed);
                        });
                    }
                    else
                    {
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, "PDF íŒŒì¼ ì¤€ë¹„ ì™„ë£Œ", StepStatus.Completed);
                        });
                    }
                    currentStep++;
                    
                    // Step 3: PDF ì½ê¸°
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "PDF íŒŒì¼ ì½ëŠ” ì¤‘...", StepStatus.InProgress);
                    });
                      int totalPages = 0;
                    using (var reader = new PdfReader(pdfPath))
                    using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                    {
                        totalPages = pdfDoc.GetNumberOfPages();
                    }
                    
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, $"PDF ì½ê¸° ì™„ë£Œ ({totalPages}í˜ì´ì§€)", StepStatus.Completed);
                    });
                    currentStep++;
                    
                    // Step 4: ë¶„í•  ì²˜ë¦¬
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "PDF ë¶„í•  ì¤‘...", StepStatus.InProgress);
                    });
                    
                    SplitPdfFile(pdfPath, pageSize, fileItem, totalPages);
                    
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "PDF ë¶„í•  ì™„ë£Œ", StepStatus.Completed);
                    });
                    currentStep++;
                    
                    // Step 5: ì™„ë£Œ
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "ëª¨ë“  ì‘ì—… ì™„ë£Œ", StepStatus.Completed);
                    });
                }
                catch (Exception ex)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, $"ì˜¤ë¥˜: {ex.Message}", StepStatus.Error);
                    });
                    throw;
                }
            });
        }        private void SplitPdfFile(string pdfPath, int pageSize, FileItem fileItem, int totalPages)
        {            using (var reader = new PdfReader(pdfPath))
            using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
            {
                string outputDir = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(pdfPath) ?? "", "output_split");
                
                if (!Directory.Exists(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }
                
                for (int startPage = 1; startPage <= totalPages; startPage += pageSize)
                {
                    int endPage = Math.Min(startPage + pageSize - 1, totalPages);
                    
                    string outputFileName = $"{System.IO.Path.GetFileNameWithoutExtension(pdfPath)}_page{startPage:D2}-{endPage:D2}.pdf";
                    string outputFilePath = System.IO.Path.Combine(outputDir, outputFileName);
                    
                    using (var writer = new iText.Kernel.Pdf.PdfWriter(outputFilePath))
                    using (var newPdfDoc = new iText.Kernel.Pdf.PdfDocument(writer))
                    {
                        pdfDoc.CopyPagesTo(startPage, endPage, newPdfDoc);
                    }
                }
            }
        }

        /// <summary>
        /// Syncfusionì„ ì‚¬ìš©í•˜ì—¬ Word íŒŒì¼ì„ PDFë¡œ ë³€í™˜í•©ë‹ˆë‹¤. (Office ì„¤ì¹˜ ë¶ˆí•„ìš”)
        /// </summary>
        /// <param name="wordFilePath">ë³€í™˜í•  Word íŒŒì¼ ê²½ë¡œ</param>
        /// <returns>ìƒì„±ëœ PDF íŒŒì¼ ê²½ë¡œ</returns>
        private string ConvertWordToPdfFileWithSyncfusion(string wordFilePath)
        {
            try
            {
                LogMessage($"ConvertWordToPdfFileWithSyncfusion ì‹œì‘ - Word: {wordFilePath}");
                
                // íŒŒì¼ ì¡´ì¬ í™•ì¸
                if (!File.Exists(wordFilePath))
                {
                    throw new FileNotFoundException($"Word íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {wordFilePath}");
                }
                
                string outputPath = System.IO.Path.ChangeExtension(wordFilePath, ".pdf");
                LogMessage($"ì˜ˆìƒ ì¶œë ¥ ê²½ë¡œ: {outputPath}");
                
                // ì¶œë ¥ íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš° ë°±ì—… ìƒì„±
                if (File.Exists(outputPath))
                {
                    string backupPath = System.IO.Path.ChangeExtension(outputPath, $".backup_{DateTime.Now:yyyyMMdd_HHmmss}.pdf");
                    File.Move(outputPath, backupPath);
                    LogMessage($"ê¸°ì¡´ PDF íŒŒì¼ì„ ë°±ì—…ìœ¼ë¡œ ì´ë™: {backupPath}");
                }
                
                // Word ë¬¸ì„œ íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì—´ê¸° (ì½ê¸° ì „ìš©, ê³µìœ  ì½ê¸° í—ˆìš©)
                using (FileStream fileStream = new FileStream(wordFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    LogMessage($"Word íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì—´ê¸° ì„±ê³µ");
                    
                    // ê¸°ì¡´ Word ë¬¸ì„œ ë¡œë“œ
                    using (WordDocument wordDocument = new WordDocument(fileStream, FormatType.Automatic))
                    {
                        LogMessage($"Word ë¬¸ì„œ ë¡œë“œ ì„±ê³µ - ì„¹ì…˜ ìˆ˜: {wordDocument.Sections.Count}");
                        
                        // DocIORenderer ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
                        using (DocIORenderer renderer = new DocIORenderer())
                        {
                            LogMessage($"DocIORenderer ìƒì„± ì„±ê³µ");
                            
                            // Word ë¬¸ì„œë¥¼ PDF ë¬¸ì„œë¡œ ë³€í™˜
                            using (Syncfusion.Pdf.PdfDocument pdfDocument = renderer.ConvertToPDF(wordDocument))
                            {
                                LogMessage($"PDF ë³€í™˜ ì„±ê³µ - í˜ì´ì§€ ìˆ˜: {pdfDocument.Pages.Count}");
                                
                                // PDF íŒŒì¼ì„ íŒŒì¼ ì‹œìŠ¤í…œì— ì €ì¥ (ì“°ê¸° ì „ìš©)
                                using (FileStream outputStream = new FileStream(outputPath, FileMode.Create, FileAccess.Write, FileShare.None))
                                {
                                    pdfDocument.Save(outputStream);
                                    LogMessage($"PDF íŒŒì¼ ì €ì¥ ì„±ê³µ: {outputPath}");
                                }
                            }
                        }
                    }
                }
                
                // íŒŒì¼ì´ ì‹¤ì œë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
                if (File.Exists(outputPath))
                {
                    var fileInfo = new FileInfo(outputPath);
                    LogMessage($"ë³€í™˜ëœ PDF íŒŒì¼ í™•ì¸: {outputPath}, í¬ê¸°: {fileInfo.Length} bytes");
                    
                    // íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ê²½ê³ 
                    if (fileInfo.Length < 1024) // 1KB ë¯¸ë§Œ
                    {
                        LogMessage($"ê²½ê³ : ìƒì„±ëœ PDF íŒŒì¼ í¬ê¸°ê°€ ë§¤ìš° ì‘ìŠµë‹ˆë‹¤ ({fileInfo.Length} bytes). ë‚´ìš©ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.", level: "WARN");
                    }
                }
                else
                {
                    LogMessage($"ë³€í™˜ëœ PDF íŒŒì¼ ìƒì„± ì‹¤íŒ¨: {outputPath}", level: "ERROR");
                    throw new FileNotFoundException($"ë³€í™˜ëœ PDF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {outputPath}");
                }
                
                LogMessage($"ConvertWordToPdfFileWithSyncfusion ì™„ë£Œ - ë°˜í™˜: {outputPath}");
                return outputPath;
            }
            catch (UnauthorizedAccessException ex)
            {
                LogMessage($"íŒŒì¼ ì ‘ê·¼ ê¶Œí•œ ì˜¤ë¥˜: {wordFilePath}", ex, "ERROR");
                string errorMessage = $"íŒŒì¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n" +
                                    $"íŒŒì¼: {System.IO.Path.GetFileName(wordFilePath)}\n" +
                                    $"ì˜¤ë¥˜: íŒŒì¼ì´ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš© ì¤‘ì´ê±°ë‚˜ ì½ê¸° ì „ìš©ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n" +
                                    $"í•´ê²° ë°©ë²•:\n" +
                                    $"â€¢ Wordì—ì„œ íŒŒì¼ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„\n" +
                                    $"â€¢ íŒŒì¼ì˜ ì½ê¸° ì „ìš© ì†ì„± í•´ì œ\n" +
                                    $"â€¢ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰";
                
                MessageBox.Show(errorMessage, "íŒŒì¼ ì ‘ê·¼ ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                throw;
            }
            catch (IOException ex)
            {
                LogMessage($"íŒŒì¼ I/O ì˜¤ë¥˜: {wordFilePath}", ex, "ERROR");
                string errorMessage = $"íŒŒì¼ ì½ê¸°/ì“°ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\n" +
                                    $"íŒŒì¼: {System.IO.Path.GetFileName(wordFilePath)}\n" +
                                    $"ì˜¤ë¥˜: {ex.Message}\n\n" +
                                    $"ê°€ëŠ¥í•œ ì›ì¸:\n" +
                                    $"â€¢ ë””ìŠ¤í¬ ê³µê°„ ë¶€ì¡±\n" +
                                    $"â€¢ íŒŒì¼ì´ ì†ìƒë¨\n" +
                                    $"â€¢ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œ (ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œì˜ ê²½ìš°)";
                
                MessageBox.Show(errorMessage, "íŒŒì¼ I/O ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                throw;
            }
            catch (Exception ex)
            {
                // ë¡œê·¸ íŒŒì¼ì— ì˜¤ë¥˜ ê¸°ë¡
                LogMessage($"Syncfusion Wordâ†’PDF ë³€í™˜ ì‹¤íŒ¨: {wordFilePath}", ex, "ERROR");
                
                // ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
                string errorMessage = $"Word íŒŒì¼ì„ PDFë¡œ ë³€í™˜í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\n" +
                                    $"íŒŒì¼: {System.IO.Path.GetFileName(wordFilePath)}\n" +
                                    $"ì˜¤ë¥˜: {ex.Message}\n\n" +
                                    $"ê°€ëŠ¥í•œ ì›ì¸:\n" +
                                    $"â€¢ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ì•”í˜¸ë¡œ ë³´í˜¸ë¨\n" +
                                    $"â€¢ ì§€ì›ë˜ì§€ ì•ŠëŠ” Word ë¬¸ì„œ í˜•ì‹\n" +
                                    $"â€¢ Syncfusion ë¼ì´ì„ ìŠ¤ ë¬¸ì œ\n" +
                                    $"â€¢ ë©”ëª¨ë¦¬ ë¶€ì¡±\n\n" +
                                    $"ìƒì„¸í•œ ì˜¤ë¥˜ ì •ë³´ëŠ” ë¡œê·¸ íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.";
                
                MessageBox.Show(errorMessage, "Wordâ†’PDF ë³€í™˜ ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                
                throw; // ìƒìœ„ í˜¸ì¶œìì—ê²Œ ì˜ˆì™¸ ì „íŒŒ
            }
        }

        /// <summary>
        /// Word íŒŒì¼ì„ PDFë¡œ ë³€í™˜í•©ë‹ˆë‹¤. (Syncfusion ë°©ì‹ ì‚¬ìš©)
        /// </summary>
        /// <param name="wordFilePath">ë³€í™˜í•  Word íŒŒì¼ ê²½ë¡œ</param>
        /// <returns>ìƒì„±ëœ PDF íŒŒì¼ ê²½ë¡œ</returns>
        private string ConvertWordToPdfFile(string wordFilePath)
        {
            return ConvertWordToPdfFileWithSyncfusion(wordFilePath);
        }

        /// <summary>
        /// ë¡œê·¸ ë©”ì‹œì§€ë¥¼ íŒŒì¼ì— ê¸°ë¡í•©ë‹ˆë‹¤.
        /// </summary>
        /// <param name="message">ë¡œê·¸ ë©”ì‹œì§€</param>
        /// <param name="exception">ì˜ˆì™¸ ê°ì²´ (ì„ íƒì‚¬í•­)</param>
        /// <param name="level">ë¡œê·¸ ë ˆë²¨</param>
        private void LogMessage(string message, Exception? exception = null, string level = "INFO")
        {
            try
            {
                string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
                string logDirectory = System.IO.Path.Combine(baseDirectory, "logs");
                
                if (!Directory.Exists(logDirectory))
                {
                    Directory.CreateDirectory(logDirectory);
                }
                
                string logFile = System.IO.Path.Combine(logDirectory, $"pdfsplitter-{DateTime.Now:yyyy-MM-dd}.log");
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} [{level}] {message}\n";
                
                if (exception != null)
                {
                    logEntry += $"Exception: {exception.GetType().FullName}: {exception.Message}\n";
                    if (exception.StackTrace != null)
                    {
                        logEntry += $"StackTrace: {exception.StackTrace}\n";
                    }
                    logEntry += "--------------------------------------------------\n";
                }
                
                File.AppendAllText(logFile, logEntry);
            }
            catch
            {
                // ë¡œê¹… ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
            }
        }

        /// <summary>
        /// ì˜¤ë¥˜ë¥¼ ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡í•©ë‹ˆë‹¤. (í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼)
        /// </summary>
        /// <param name="message">ì˜¤ë¥˜ ë©”ì‹œì§€</param>
        /// <param name="exception">ì˜ˆì™¸ ê°ì²´</param>
        private void LogError(string message, Exception exception)
        {
            LogMessage(message, exception, "ERROR");
        }

        #region ë©”ë‰´ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

        private void MenuItem_New_Click(object sender, RoutedEventArgs e)
        {
            // ìƒˆ íŒŒì¼ - í˜„ì¬ íŒŒì¼ ëª©ë¡ ì´ˆê¸°í™”
            fileItems.Clear();
            txtStatus.Text = "âœ… ì¤€ë¹„ë¨";
        }

        private void MenuItem_Open_Click(object sender, RoutedEventArgs e)
        {
            // íŒŒì¼ ì—´ê¸° - ê¸°ì¡´ íŒŒì¼ ì¶”ê°€ ê¸°ëŠ¥ í˜¸ì¶œ
            BtnAddFiles_Click(sender, e);
        }

        private void MenuItem_Save_Click(object sender, RoutedEventArgs e)
        {
            // ì €ì¥ ê¸°ëŠ¥ (í˜„ì¬ êµ¬í˜„í•˜ì§€ ì•ŠìŒ)
            MessageBox.Show("ì €ì¥ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Exit_Click(object sender, RoutedEventArgs e)
        {
            // í”„ë¡œê·¸ë¨ ì¢…ë£Œ
            this.Close();
        }

        private void MenuItem_Undo_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ì‹¤í–‰ ì·¨ì†Œ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Cut_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ì˜ë¼ë‚´ê¸° ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Copy_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ë³µì‚¬ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Paste_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ë¶™ì—¬ë„£ê¸° ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_FontSize_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.Tag is string fontSizeStr)
            {
                if (double.TryParse(fontSizeStr, out double fontSize))
                {
                    // Windowì˜ FontSizeë¥¼ ë³€ê²½í•˜ì—¬ ëª¨ë“  ì»¨íŠ¸ë¡¤ì— ìƒì†
                    this.FontSize = fontSize;
                    
                    // ë©”ë‰´ ì²´í¬ ìƒíƒœ ì—…ë°ì´íŠ¸
                    UpdateFontSizeMenuItems(fontSize);
                }
            }
        }

        private void UpdateFontSizeMenuItems(double currentFontSize)
        {
            // ë©”ë‰´ ì°¾ê¸° - Gridì—ì„œ Menu ì°¾ê¸°
            if (this.Content is Grid grid)
            {
                var menu = FindVisualChild<Menu>(grid);
                if (menu != null)
                {
                    var optionsMenu = menu.Items.OfType<MenuItem>().FirstOrDefault(m => m.Header.ToString() == "Options");
                    if (optionsMenu != null)
                    {
                        var fontSizeMenu = optionsMenu.Items.OfType<MenuItem>().FirstOrDefault(m => m.Header.ToString() == "Font Size");
                        if (fontSizeMenu != null)
                        {
                            // ëª¨ë“  í•˜ìœ„ ë©”ë‰´ ì•„ì´í…œì˜ ì²´í¬ í•´ì œ
                            foreach (MenuItem item in fontSizeMenu.Items.OfType<MenuItem>())
                            {
                                item.IsChecked = false;
                            }

                            // í˜„ì¬ ì„ íƒëœ í¬ê¸°ì˜ ë©”ë‰´ ì•„ì´í…œ ì²´í¬
                            var targetMenuItem = fontSizeMenu.Items.OfType<MenuItem>()
                                .FirstOrDefault(m => m.Tag?.ToString() == currentFontSize.ToString());
                            if (targetMenuItem != null)
                            {
                                targetMenuItem.IsChecked = true;
                            }
                        }
                    }
                }
            }
        }        private T? FindVisualChild<T>(DependencyObject parent) where T : DependencyObject
        {
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                if (child is T result)
                    return result;
                
                var childOfChild = FindVisualChild<T>(child);
                if (childOfChild != null)
                    return childOfChild;
            }
            return null;
        }        private void MenuItem_About_Click(object sender, RoutedEventArgs e)        {
            MessageBox.Show("PDF Splitter for Copilot v1.1\n\nCopilotì˜ RAGê²€ìƒ‰ì´ ì •í™•í•˜ë„ë¡ PDF ë¶„í• ë„êµ¬ì…ë‹ˆë‹¤.\n\nìƒˆë¡œìš´ ê¸°ëŠ¥:\nâ€¢ Syncfusionì„ í†µí•œ Wordâ†’PDF ë³€í™˜\nâ€¢ ë¼ì´ì„ ìŠ¤ í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ\nâ€¢ CLI í…ŒìŠ¤íŠ¸ ìœ í‹¸ë¦¬í‹°", 
                   "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Welcome_Click(object sender, RoutedEventArgs e)
        {
            var welcomeMessage = @"ğŸ‰ PDF Splitter for Copilotì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!

    ğŸ“– ì‚¬ìš© ë°©ë²•:
    â€¢ íŒŒì¼ ì¶”ê°€ ë²„íŠ¼ì„ í´ë¦­í•˜ê±°ë‚˜ PDF íŒŒì¼ì„ ë“œë˜ê·¸í•˜ì—¬ ì¶”ê°€í•˜ì„¸ìš”
    â€¢ ë¶„í• í•  í˜ì´ì§€ ìˆ˜ë¥¼ ì„¤ì •í•˜ì„¸ìš” (ê¸°ë³¸ê°’: 10í˜ì´ì§€)
    â€¢ ë¶„í•  ì‹¤í–‰ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì²˜ë¦¬ë¥¼ ì‹œì‘í•˜ì„¸ìš”

    âœ¨ ì£¼ìš” ê¸°ëŠ¥:
    â€¢ ëŒ€ìš©ëŸ‰ PDF íŒŒì¼ ìë™ ë¶„í• 
    â€¢ ì§„í–‰ ìƒí™© ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
    â€¢ ë‹¤ì¤‘ íŒŒì¼ ë™ì‹œ ì²˜ë¦¬ ì§€ì›
    â€¢ Fluent Design ê¸°ë°˜ í˜„ëŒ€ì  UI

    ğŸ’¡ íŒ: 
    â€¢ íŒŒì¼ ê²½ë¡œë¥¼ í´ë¦­í•˜ë©´ í•´ë‹¹ í´ë”ê°€ ì—´ë¦½ë‹ˆë‹¤
    â€¢ ì§„í–‰ ìƒí™© ì•„ì´ì½˜ì„ í´ë¦­í•˜ë©´ ìƒì„¸ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

    ğŸ“ ë¬¸ì˜ì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ Help > Aboutì„ ì°¸ì¡°í•˜ì„¸ìš”.";
            
            MessageBox.Show(welcomeMessage, "í™˜ì˜í•©ë‹ˆë‹¤!", 
                   MessageBoxButton.OK, MessageBoxImage.Information);
        }        private void StatusBrush_Click(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            // ìƒíƒœ ì•„ì´ì½˜ í´ë¦­ ì‹œ ìƒì„¸ ì •ë³´ í‘œì‹œ
            if (sender is Rectangle rect && rect.Tag is FileItem fileItem)
            {
                string message = $"íŒŒì¼ëª…: {fileItem.FileName}\nìƒíƒœ: {fileItem.StatusMessage}";
                if (fileItem.Steps != null && fileItem.Steps.Any())
                {
                    message += "\n\n[ì²˜ë¦¬ ë‹¨ê³„]";
                    foreach (var step in fileItem.Steps)
                    {
                        message += $"\n- {step.Name}: {step.Status} ({step.Message})";
                    }
                }
                
                // ì™„ë£Œëœ íŒŒì¼ì˜ ê²½ìš° output í´ë” ì—´ê¸° ì˜µì…˜ ì œê³µ
                bool isCompleted = fileItem.Steps != null && fileItem.Steps.Any() && 
                                 fileItem.Steps.Last().Status == StepStatus.Completed;
                
                if (isCompleted && !string.IsNullOrEmpty(fileItem.FilePath))
                {
                    var result = MessageBox.Show(message + "\n\nì²˜ë¦¬ëœ íŒŒì¼ë“¤ì´ ì €ì¥ëœ í´ë”ë¥¼ ì—´ì–´ë³´ì‹œê² ìŠµë‹ˆê¹Œ?", 
                        "ìƒì„¸ ìƒíƒœ ì •ë³´", MessageBoxButton.YesNo, MessageBoxImage.Information);
                    
                    if (result == MessageBoxResult.Yes)
                    {
                        try
                        {
                            string? directoryPath = System.IO.Path.GetDirectoryName(fileItem.FilePath);
                            if (!string.IsNullOrEmpty(directoryPath))
                            {
                                // ë¶„í•  ë° ë³€í™˜ ì‘ì—… ëª¨ë‘ ë™ì¼í•œ output_split í´ë” ì‚¬ìš©
                                string outputSplitPath = System.IO.Path.Combine(directoryPath, "output_split");
                                
                                if (Directory.Exists(outputSplitPath))
                                {
                                    System.Diagnostics.Process.Start("explorer.exe", outputSplitPath);
                                }
                                else
                                {
                                    MessageBox.Show("output_split í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Warning);
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show($"í´ë” ì—´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {ex.Message}", "ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                        }
                    }
                }
                else
                {
                    MessageBox.Show(message, "ìƒì„¸ ìƒíƒœ ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
        }

        private void FilePath_Click(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            if (sender is TextBlock textBlock && textBlock.Tag is string filePath)
            {
                if (string.IsNullOrEmpty(filePath)) // Check if filePath is null or empty
                {
                    MessageBox.Show("íŒŒì¼ ê²½ë¡œê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", "ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                try
                {
                    // íŒŒì¼ ê²½ë¡œì—ì„œ ë””ë ‰í† ë¦¬ ê²½ë¡œ ì¶”ì¶œ
                    string? directoryPath = System.IO.Path.GetDirectoryName(filePath); // Use string? for nullable
                    if (!string.IsNullOrEmpty(directoryPath) && Directory.Exists(directoryPath))
                    {
                        // íƒìƒ‰ê¸°ë¡œ í•´ë‹¹ í´ë” ì—´ê¸°
                        System.Diagnostics.Process.Start("explorer.exe", directoryPath);
                    }
                    else
                    {
                        MessageBox.Show("í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }
                catch (ArgumentException aex) // Catch specific exceptions if filePath is invalid for Path.GetDirectoryName
                {
                    MessageBox.Show($"íŒŒì¼ ê²½ë¡œ ê´€ë ¨ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {aex.Message}", "ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"í´ë”ë¥¼ ì—¬ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {ex.Message}", "ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        #endregion

        /// <summary>
        /// ë³€í™˜ ì‘ì—…ì„ ìœ„í•œ ê°œë³„ íŒŒì¼ ì²˜ë¦¬ (ì²« ë²ˆì§¸ ë¶€ë¶„ë§Œ ì¶”ì¶œ)
        /// </summary>
        /// <param name="fileItem">ì²˜ë¦¬í•  íŒŒì¼ ì•„ì´í…œ</param>
        /// <param name="pageLimit">ì¶”ì¶œí•  í˜ì´ì§€ ìˆ˜</param>
        private async System.Threading.Tasks.Task ProcessConvertFileAsync(FileItem fileItem, int pageLimit)
        {
            // ê³ ì •ëœ 4ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤ (ë³€í™˜/ì¶”ì¶œìš©)
            int totalSteps = 4;
            
            try
            {
                // ë””ë²„ê¹…ìš© ë¡œê·¸
                LogMessage($"ProcessConvertFileAsync ì‹œì‘ - íŒŒì¼: {fileItem.FileName}, í˜ì´ì§€ ì œí•œ: {pageLimit}");
                
                // Initialize progress tracking
                Application.Current.Dispatcher.Invoke(() =>
                {
                    fileItem.TotalSteps = totalSteps;
                    fileItem.CurrentStep = 0;
                    fileItem.StepMessage = "ì¤€ë¹„ ì¤‘...";
                    
                    // Initialize steps collection with 4 fixed steps
                    fileItem.Steps.Clear();
                    string[] stepNames = { "íŒŒì¼ ê²€ì¦", "PDF ì¤€ë¹„", "í˜ì´ì§€ ì¶”ì¶œ", "ì™„ë£Œ" };
                    for (int i = 0; i < totalSteps; i++)
                    {
                        fileItem.Steps.Add(new StepItem
                        {
                            Name = stepNames[i],
                            Status = StepStatus.Pending,
                            Message = "ëŒ€ê¸° ì¤‘..."
                        });
                    }
                });
                
                await System.Threading.Tasks.Task.Run(() =>
                {
                    int currentStep = 0;
                    string pdfPath = fileItem.FilePath;
                    
                    // Step 1: íŒŒì¼ ê²€ì¦
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "íŒŒì¼ í˜•ì‹ ê²€ì¦ ì¤‘...", StepStatus.InProgress);
                    });
                    
                    try
                    {
                        string extension = System.IO.Path.GetExtension(fileItem.FilePath).ToLower();
                        LogMessage($"íŒŒì¼ í™•ì¥ì í™•ì¸: {extension}");
                        
                        if (extension != ".pdf" && extension != ".doc" && extension != ".docx")
                        {
                            throw new NotSupportedException("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.");
                        }
                        
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, $"íŒŒì¼ ê²€ì¦ ì™„ë£Œ ({extension})", StepStatus.Completed);
                        });
                        currentStep++;
                        
                        // Step 2: PDF ì¤€ë¹„ (Word íŒŒì¼ì¸ ê²½ìš° PDFë¡œ ë³€í™˜)
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, "PDF ì¤€ë¹„ ì¤‘...", StepStatus.InProgress);
                        });
                        
                        if (extension != ".pdf")
                        {
                            LogMessage($"Word íŒŒì¼ ë³€í™˜ ì‹œì‘: {fileItem.FilePath}");
                            pdfPath = ConvertWordToPdfFile(fileItem.FilePath);
                            LogMessage($"Word íŒŒì¼ ë³€í™˜ ì™„ë£Œ: {pdfPath}");
                            
                            Application.Current.Dispatcher.Invoke(() =>
                            {
                                fileItem.UpdateStep(currentStep, "Word â†’ PDF ë³€í™˜ ì™„ë£Œ", StepStatus.Completed);
                            });
                        }
                        else
                        {
                            LogMessage($"PDF íŒŒì¼ ì²˜ë¦¬: {pdfPath}");
                            Application.Current.Dispatcher.Invoke(() =>
                            {
                                fileItem.UpdateStep(currentStep, "PDF íŒŒì¼ ì¤€ë¹„ ì™„ë£Œ", StepStatus.Completed);
                            });
                        }
                        currentStep++;
                        
                        // Step 3: í˜ì´ì§€ ì¶”ì¶œ (ì²« ë²ˆì§¸ ë¶€ë¶„ë§Œ)
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, $"1~{pageLimit}í˜ì´ì§€ ì¶”ì¶œ ì¤‘...", StepStatus.InProgress);
                        });
                        
                        LogMessage($"í˜ì´ì§€ ì¶”ì¶œ ì‹œì‘: {pdfPath}, ì œí•œ: {pageLimit}");
                        int extractedPages = ExtractPdfPagesWithResult(pdfPath, pageLimit);
                        LogMessage($"í˜ì´ì§€ ì¶”ì¶œ ì™„ë£Œ: {extractedPages}í˜ì´ì§€");
                        
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, $"í˜ì´ì§€ ì¶”ì¶œ ì™„ë£Œ ({extractedPages}í˜ì´ì§€)", StepStatus.Completed);
                        });
                        currentStep++;
                        
                        // Step 4: ì™„ë£Œ
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, "ëª¨ë“  ì‘ì—… ì™„ë£Œ", StepStatus.Completed);
                            fileItem.StatusColor = Brushes.Green;
                            fileItem.StatusMessage = $"ì™„ë£Œ: 1~{extractedPages}í˜ì´ì§€ ì¶”ì¶œë¨";
                        });
                        
                        LogMessage($"ProcessConvertFileAsync ì™„ë£Œ - íŒŒì¼: {fileItem.FileName}");
                    }
                    catch (Exception ex)
                    {
                        LogMessage($"ProcessConvertFileAsync ì˜¤ë¥˜ - íŒŒì¼: {fileItem.FileName}", ex, "ERROR");
                        
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, $"ì˜¤ë¥˜: {ex.Message}", StepStatus.Error);
                            fileItem.StatusColor = Brushes.Red;
                            fileItem.StatusMessage = $"ì˜¤ë¥˜: {ex.Message}";
                        });
                        throw;
                    }
                });
            }
            catch (Exception ex)
            {
                LogMessage($"ProcessConvertFileAsync ìµœìƒìœ„ ì˜¤ë¥˜ - íŒŒì¼: {fileItem.FileName}", ex, "ERROR");
                throw;
            }
        }

        /// <summary>
        /// PDF íŒŒì¼ì—ì„œ 1í˜ì´ì§€ë¶€í„° ì§€ì •ëœ í˜ì´ì§€ê¹Œì§€ë§Œ ë¶„ë¦¬í•©ë‹ˆë‹¤. (ê²°ê³¼ ë°˜í™˜ ë²„ì „)
        /// </summary>
        /// <param name="pdfPath">ì›ë³¸ PDF íŒŒì¼ ê²½ë¡œ</param>
        /// <param name="pageLimit">ë¶„ë¦¬í•  í˜ì´ì§€ ìˆ˜ (1ë¶€í„° ì´ ìˆ«ìê¹Œì§€)</param>
        /// <returns>ì‹¤ì œë¡œ ë¶„ë¦¬ëœ í˜ì´ì§€ ìˆ˜</returns>
        private int ExtractPdfPagesWithResult(string pdfPath, int pageLimit)
        {
            try
            {
                LogMessage($"ExtractPdfPagesWithResult ì‹œì‘ - PDF: {pdfPath}, ì œí•œ: {pageLimit}");
                
                using (var reader = new PdfReader(pdfPath))
                using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                {
                    int totalPages = pdfDoc.GetNumberOfPages();
                    int extractPages = Math.Min(pageLimit, totalPages);
                    
                    LogMessage($"ì´ í˜ì´ì§€: {totalPages}, ì¶”ì¶œí•  í˜ì´ì§€: {extractPages}");
                    
                    string outputDir = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(pdfPath) ?? "", "output_split");
                    
                    LogMessage($"ì¶œë ¥ ë””ë ‰í† ë¦¬: {outputDir}");
                    
                    if (!Directory.Exists(outputDir))
                    {
                        Directory.CreateDirectory(outputDir);
                        LogMessage($"ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±ë¨: {outputDir}");
                    }
                    
                    string outputFileName = $"{System.IO.Path.GetFileNameWithoutExtension(pdfPath)}_page01-{extractPages:D2}.pdf";
                    string outputFilePath = System.IO.Path.Combine(outputDir, outputFileName);
                    
                    LogMessage($"ì¶œë ¥ íŒŒì¼ ê²½ë¡œ: {outputFilePath}");
                    
                    using (var writer = new iText.Kernel.Pdf.PdfWriter(outputFilePath))
                    using (var newPdfDoc = new iText.Kernel.Pdf.PdfDocument(writer))
                    {
                        // 1í˜ì´ì§€ë¶€í„° extractPagesê¹Œì§€ ë³µì‚¬
                        pdfDoc.CopyPagesTo(1, extractPages, newPdfDoc);
                        LogMessage($"í˜ì´ì§€ ë³µì‚¬ ì™„ë£Œ: 1~{extractPages}");
                    }
                    
                    // íŒŒì¼ì´ ì‹¤ì œë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
                    if (File.Exists(outputFilePath))
                    {
                        var fileInfo = new FileInfo(outputFilePath);
                        LogMessage($"ì¶œë ¥ íŒŒì¼ ìƒì„± í™•ì¸: {outputFilePath}, í¬ê¸°: {fileInfo.Length} bytes");
                        
                        // íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ê²½ê³ 
                        if (fileInfo.Length < 1024) // 1KB ë¯¸ë§Œ
                        {
                            LogMessage($"ê²½ê³ : ìƒì„±ëœ PDF íŒŒì¼ í¬ê¸°ê°€ ë§¤ìš° ì‘ìŠµë‹ˆë‹¤ ({fileInfo.Length} bytes). ë‚´ìš©ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.", level: "WARN");
                        }
                    }
                    else
                    {
                        LogMessage($"ì¶œë ¥ íŒŒì¼ ìƒì„± ì‹¤íŒ¨: {outputFilePath}", level: "ERROR");
                        throw new FileNotFoundException($"ì¶”ì¶œëœ PDF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {outputFilePath}");
                    }
                    
                    LogMessage($"ExtractPdfPagesWithResult ì™„ë£Œ - ë°˜í™˜ê°’: {extractPages}");
                    return extractPages;
                }
            }
            catch (Exception ex)
            {
                LogMessage($"ExtractPdfPagesWithResult ì˜¤ë¥˜ - PDF: {pdfPath}", ex, "ERROR");
                throw;
            }
        }

        /// <summary>
        /// ëª¨ë“œ í† ê¸€ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        /// </summary>
        private void TbModeSwitch_Click(object sender, RoutedEventArgs e)
        {
            // í˜„ì¬ ëª¨ë“œì— ë”°ë¼ í˜ì´ì§€ ìˆ˜ ê°’ ì €ì¥ ë° ë³€ê²½
            bool isConvertMode = tbModeSwitch.IsChecked == true;
            
            if (isConvertMode)
            {
                // ë¶„í•  ëª¨ë“œì—ì„œ ë³€í™˜ ëª¨ë“œë¡œ ë³€ê²½
                _splitModePageCount = GetCurrentPageCount(); // í˜„ì¬ ê°’ ì €ì¥
                numPageCount.Text = _convertModePageCount.ToString(); // ë³€í™˜ ëª¨ë“œ ê¸°ë³¸ê°’ ì„¤ì •
            }
            else
            {
                // ë³€í™˜ ëª¨ë“œì—ì„œ ë¶„í•  ëª¨ë“œë¡œ ë³€ê²½
                _convertModePageCount = GetCurrentPageCount(); // í˜„ì¬ ê°’ ì €ì¥
                numPageCount.Text = _splitModePageCount.ToString(); // ë¶„í•  ëª¨ë“œ ê¸°ë³¸ê°’ ì„¤ì •
            }
            
            // ì‹¤í–‰ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            UpdateProcessButtonText();
        }

        /// <summary>
        /// ìˆ«ì ì…ë ¥ë§Œ í—ˆìš©í•˜ëŠ” í…ìŠ¤íŠ¸ ì…ë ¥ ê²€ì¦
        /// </summary>
        private void NumPageCount_PreviewTextInput(object sender, System.Windows.Input.TextCompositionEventArgs e)
        {
            // ìˆ«ìë§Œ í—ˆìš© (0-9)
            e.Handled = !System.Text.RegularExpressions.Regex.IsMatch(e.Text, @"^[0-9]+$");
        }

        /// <summary>
        /// í˜ì´ì§€ ìˆ˜ í…ìŠ¤íŠ¸ ë³€ê²½ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        /// </summary>
        private void NumPageCount_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (sender is TextBox textBox)
            {
                // ë¹ˆ ë¬¸ìì—´ì´ê±°ë‚˜ 0ì¸ ê²½ìš° 1ë¡œ ì„¤ì •
                if (string.IsNullOrWhiteSpace(textBox.Text))
                {
                    textBox.Text = "1";
                    textBox.SelectionStart = textBox.Text.Length;
                }
                else if (int.TryParse(textBox.Text, out int value))
                {
                    // ë²”ìœ„ ì²´í¬ (1-50)
                    if (value < 1)
                    {
                        textBox.Text = "1";
                        textBox.SelectionStart = textBox.Text.Length;
                    }
                    else if (value > 50)
                    {
                        textBox.Text = "50";
                        textBox.SelectionStart = textBox.Text.Length;
                    }
                }
                else
                {
                    // ìˆ«ìê°€ ì•„ë‹Œ ê²½ìš° 1ë¡œ ì„¤ì •
                    textBox.Text = "1";
                    textBox.SelectionStart = textBox.Text.Length;
                }
            }
        }

        /// <summary>
        /// í˜„ì¬ í˜ì´ì§€ ìˆ˜ ê°’ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
        /// </summary>
        private int GetCurrentPageCount()
        {
            if (int.TryParse(numPageCount.Text, out int value) && value >= 1 && value <= 50)
            {
                return value;
            }
            return 1; // ê¸°ë³¸ê°’
        }

        private void CheckBox_Checked(object sender, RoutedEventArgs e)
        {
            // ì²´í¬ë°•ìŠ¤ê°€ ì„ íƒë˜ì—ˆì„ ë•Œì˜ ì²˜ë¦¬ (í•„ìš”ì‹œ)
        }

        private void CheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            // ì²´í¬ë°•ìŠ¤ê°€ í•´ì œë˜ì—ˆì„ ë•Œì˜ ì²˜ë¦¬ (í•„ìš”ì‹œ)
        }

        private void BtnRemoveSelected_Click(object sender, RoutedEventArgs e)
        {
            var selectedItems = fileItems.Where(f => f.IsSelected).ToList();
            
            foreach (var item in selectedItems)
            {
                fileItems.Remove(item);
            }
            
            txtStatus.Text = $"ì´ {fileItems.Count}ê°œ íŒŒì¼ ë“±ë¡ë¨";
            OnPropertyChanged(nameof(HasFiles));
            OnPropertyChanged(nameof(NoFiles));
        }

        public void Window_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                e.Effects = DragDropEffects.Copy;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        public async void Window_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
                await AddFilesToCollection(files);
            }
        }

        public async void BtnAddFiles_Click(object sender, RoutedEventArgs e)
        {
            OpenFileDialog dialog = new OpenFileDialog
            {
                Multiselect = true,
                Filter = "PDF ë° Word íŒŒì¼|*.pdf;*.doc;*.docx|PDF íŒŒì¼|*.pdf|Word íŒŒì¼|*.doc;*.docx"
            };

            if (dialog.ShowDialog() == true)
            {
                await AddFilesToCollection(dialog.FileNames);
            }
        }
        
        private async System.Threading.Tasks.Task AddFilesToCollection(string[] filePaths)
        {
            txtStatus.Text = "íŒŒì¼ ê²€ì‚¬ ì¤‘...";
            
            foreach (string filePath in filePaths)
            {
                var fileItem = new FileItem
                {
                    FileName = System.IO.Path.GetFileName(filePath),
                    FilePath = filePath,
                    StatusColor = Brushes.Yellow,
                    StatusMessage = "ê²€ì‚¬ ì¤‘...",
                    PageCount = "ê²€ì‚¬ ì¤‘..."
                };

                fileItems.Add(fileItem);
                
                // íŒŒì¼ ê²€ì¦ì„ ë¹„ë™ê¸°ë¡œ ìˆ˜í–‰
                await ValidateFileAsync(fileItem);
            }
            
            txtStatus.Text = $"ì´ {fileItems.Count}ê°œ íŒŒì¼ ë“±ë¡ë¨";
            OnPropertyChanged(nameof(HasFiles));
            OnPropertyChanged(nameof(NoFiles));
            
            // Attach remove button event handlers for new items
            AttachRemoveButtonHandlers();
        }

        private void AttachRemoveButtonHandlers()
        {
            // This will be called whenever the DataGrid is updated
            // The actual event handler attachment happens through the XAML template
            // We'll handle this through the BtnRemove_Click method which gets the item from the button's Tag
        }

        private async System.Threading.Tasks.Task ValidateFileAsync(FileItem fileItem)
        {
            try
            {
                string extension = System.IO.Path.GetExtension(fileItem.FilePath).ToLower();
                
                if (extension == ".pdf")
                {
                    await ValidatePdfFileAsync(fileItem);
                }
                else if (extension == ".doc" || extension == ".docx")
                {
                    // Syncfusionì„ ì‚¬ìš©í•˜ë¯€ë¡œ MS Word ì„¤ì¹˜ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ë³€í™˜ ê°€ëŠ¥
                    fileItem.PageCount = "ë³€í™˜ í›„ í™•ì¸";
                    fileItem.StatusColor = Brushes.Orange;
                    fileItem.StatusMessage = "Wordâ†’PDF ë³€í™˜ í•„ìš”";
                }
                else
                {
                    fileItem.StatusColor = Brushes.Red;
                    fileItem.StatusMessage = "ì§€ì›í•˜ì§€ ì•ŠëŠ” í˜•ì‹";
                    fileItem.PageCount = "N/A";
                }
            }
            catch (Exception ex)
            {
                fileItem.StatusColor = Brushes.Red;
                fileItem.StatusMessage = $"ì˜¤ë¥˜: {ex.Message}";
                fileItem.PageCount = "N/A";
            }
        }

        private async System.Threading.Tasks.Task ValidatePdfFileAsync(FileItem fileItem)
        {
            await System.Threading.Tasks.Task.Run(() =>
            {                try
                {
                    var reader = new PdfReader(fileItem.FilePath);
                    using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                    {
                        int pageCount = pdfDoc.GetNumberOfPages();
                        // Calculate blank pages ratio
                        int blankCount = 0;
                        for (int i = 1; i <= pageCount; i++)
                        {
                            var page = pdfDoc.GetPage(i);
                            if (page.GetContentBytes().Length == 0)
                                blankCount++;
                        }
                        double blankRatio = blankCount / (double)pageCount;

                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.PageCount = pageCount.ToString();
                            fileItem.StatusColor = Brushes.Green;
                            fileItem.StatusMessage = "ì²˜ë¦¬ ê°€ëŠ¥";
                            fileItem.BlankPageRatio = blankRatio;
                        });
                    }
                }
                catch (iText.Kernel.Exceptions.BadPasswordException)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.StatusColor = Brushes.Red;
                        fileItem.StatusMessage = "ì•”í˜¸ê°€ í•„ìš”í•¨";
                        fileItem.PageCount = "N/A";
                    });
                }
                catch (Exception ex)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.StatusColor = Brushes.Red;
                        fileItem.StatusMessage = $"ì˜¤ë¥˜: {ex.Message}";
                        fileItem.PageCount = "N/A";
                    });
                }
            });        }
          public async void BtnProcess_Click(object sender, RoutedEventArgs e)
        {
            int pageSize = (int)numPageCount.Value;
            if (pageSize <= 0)
            {
                MessageBox.Show("ì˜¬ë°”ë¥¸ í˜ì´ì§€ ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”.", "ì˜¤ë¥˜");
                return;
            }

            // ëª¨ë“œ í™•ì¸ (ë¶„í•  ë˜ëŠ” ë³€í™˜) - í† ê¸€ ë²„íŠ¼ ê¸°ë°˜
            bool isConvertMode = tbModeSwitch.IsChecked == true;
            
            // ì²´í¬ëœ íŒŒì¼ë§Œ í•„í„°ë§
            var selectedFiles = fileItems.Where(f => f.IsSelected).ToList();
            if (!selectedFiles.Any())
            {
                MessageBox.Show("ì²˜ë¦¬í•  íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.", "ì•Œë¦¼");
                return;
            }

            // ì„ íƒëœ íŒŒì¼ ì¤‘ ìœ íš¨í•œ íŒŒì¼ë§Œ í•„í„°ë§ (OrangeëŠ” Word íŒŒì¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ ìƒíƒœ)
            var validFiles = selectedFiles.Where(f => f.StatusColor == Brushes.Green || f.StatusColor == Brushes.Orange).ToList();
            
            // ì²˜ë¦¬ ë¶ˆê°€ëŠ¥í•œ íŒŒì¼ë“¤ í™•ì¸ (Red ìƒíƒœ)
            var invalidFiles = selectedFiles.Where(f => f.StatusColor == Brushes.Red).ToList();
            
            if (invalidFiles.Any())
            {
                var result = MessageBox.Show(
                    $"ë‹¤ìŒ {invalidFiles.Count}ê°œì˜ íŒŒì¼ì€ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:\n\n" +
                    string.Join("\n", invalidFiles.Select(f => $"{f.FileName} - {f.StatusMessage}")) + "\n\n" +
                    "ì²˜ë¦¬ ê°€ëŠ¥í•œ íŒŒì¼ë§Œ ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                    "ì²˜ë¦¬ ë¶ˆê°€ íŒŒì¼ ì¡´ì¬", 
                    MessageBoxButton.YesNo, 
                    MessageBoxImage.Warning);
                    
                if (result == MessageBoxResult.No)
                {
                    return;
                }
            }
            
            if (!validFiles.Any())
            {
                MessageBox.Show("ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.", "ì•Œë¦¼");
                return;
            }

            // í™•ì¸ì°½ í‘œì‹œ (ëª¨ë“œì— ë”°ë¼ ë©”ì‹œì§€ ë³€ê²½)
            string modeText = isConvertMode ? "ë³€í™˜" : "ë¶„í• ";
            string detailText = isConvertMode ? 
                $"ê° íŒŒì¼ë‹¹ 1~{pageSize}í˜ì´ì§€ ì¶”ì¶œ" : 
                $"ë¶„í•  í˜ì´ì§€ ìˆ˜: {pageSize}í˜ì´ì§€";
                
            var confirmResult = MessageBox.Show(
                $"ì´ {validFiles.Count}ê°œì˜ íŒŒì¼ì„ {modeText}í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n{detailText}", 
                $"{modeText} í™•ì¸", 
                MessageBoxButton.YesNo, 
                MessageBoxImage.Question);

            if (confirmResult != MessageBoxResult.Yes)
            {
                return;
            }

            progressContainer.Visibility = Visibility.Visible;
            progressBar.Maximum = validFiles.Count;
            progressBar.Value = 0;

            btnProcess.IsEnabled = false;
            
            try
            {
                foreach (var fileItem in validFiles)
                {
                    txtStatus.Text = $"ì²˜ë¦¬ ì¤‘: {fileItem.FileName}";
                    
                    try
                    {
                        if (isConvertMode)
                        {
                            await ProcessConvertFileAsync(fileItem, pageSize);
                        }
                        else
                        {
                            await ProcessFileAsync(fileItem, pageSize);
                        }
                        LogMessage($"íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ: {fileItem.FileName}");
                    }
                    catch (Exception fileEx)
                    {
                        LogMessage($"íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨: {fileItem.FileName}", fileEx, "ERROR");
                        
                        // ê°œë³„ íŒŒì¼ ì²˜ë¦¬ ì‹¤íŒ¨ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸í•˜ê³  ê³„ì† ì§„í–‰
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.StatusColor = Brushes.Red;
                            fileItem.StatusMessage = $"ì²˜ë¦¬ ì‹¤íŒ¨: {fileEx.Message}";
                            if (fileItem.Steps != null && fileItem.Steps.Any())
                            {
                                var lastStep = fileItem.Steps.Last();
                                lastStep.Status = StepStatus.Error;
                                lastStep.Message = $"ì˜¤ë¥˜: {fileEx.Message}";
                            }
                        });
                        
                        // ì‚¬ìš©ìì—ê²Œ ê°œë³„ íŒŒì¼ ì˜¤ë¥˜ ì•Œë¦¼ (ì„ íƒ ì‚¬í•­)
                        var continueResult = MessageBox.Show(
                            $"íŒŒì¼ '{fileItem.FileName}' ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n\n{fileEx.Message}\n\në‹¤ìŒ íŒŒì¼ì„ ê³„ì† ì²˜ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                            "íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜",
                            MessageBoxButton.YesNo,
                            MessageBoxImage.Warning);
                            
                        if (continueResult == MessageBoxResult.No)
                        {
                            break; // ì‚¬ìš©ìê°€ ì¤‘ë‹¨ì„ ì„ íƒí•˜ë©´ ë£¨í”„ ì¢…ë£Œ
                        }
                    }
                    
                    progressBar.Value++;
                }

                string completionMessage = isConvertMode ? 
                    $"ëª¨ë“  íŒŒì¼ ë³€í™˜ ì™„ë£Œ! ê° íŒŒì¼ë‹¹ 1~{pageSize}í˜ì´ì§€ê°€ ì¶”ì¶œë˜ì—ˆìŠµë‹ˆë‹¤." :
                    "ëª¨ë“  íŒŒì¼ ë¶„í•  ì™„ë£Œ!";
                    
                txtStatus.Text = completionMessage;
                MessageBox.Show(isConvertMode ? 
                    $"ë³€í™˜ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.\nê° íŒŒì¼ë‹¹ 1~{pageSize}í˜ì´ì§€ê°€ ì¶”ì¶œë˜ì—ˆìŠµë‹ˆë‹¤." :
                    "ë¶„í•  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.", 
                    "ì™„ë£Œ");
            }
            catch (Exception ex)
            {
                string detailedErrorMessage = $"ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{ex.GetType().FullName}: {ex.Message}\n\nStack Trace:\n{ex.StackTrace}";
                MessageBox.Show(detailedErrorMessage, "ì˜¤ë¥˜ ìƒì„¸ ì •ë³´");
                txtStatus.Text = "ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ";
            }
            finally
            {
                progressContainer.Visibility = Visibility.Collapsed;
                btnProcess.IsEnabled = true;
            }
        }

        private async System.Threading.Tasks.Task ProcessFileAsync(FileItem fileItem, int pageSize)
        {
            // ê³ ì •ëœ 5ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤
            int totalSteps = 5;
            
            // Initialize progress tracking
            Application.Current.Dispatcher.Invoke(() =>
            {
                fileItem.TotalSteps = totalSteps;
                fileItem.CurrentStep = 0;
                fileItem.StepMessage = "ì¤€ë¹„ ì¤‘...";
                
                // Initialize steps collection with 5 fixed steps
                fileItem.Steps.Clear();
                string[] stepNames = { "íŒŒì¼ ê²€ì¦", "ë¬¸ì„œ ì¤€ë¹„", "PDF ì½ê¸°", "ë¶„í•  ì²˜ë¦¬", "ì™„ë£Œ" };
                for (int i = 0; i < totalSteps; i++)
                {
                    fileItem.Steps.Add(new StepItem
                    {
                        Name = stepNames[i],
                        Status = StepStatus.Pending,
                        Message = "ëŒ€ê¸° ì¤‘..."
                    });
                }
            });            
            await System.Threading.Tasks.Task.Run(() =>
            {
                int currentStep = 0;
                string pdfPath = fileItem.FilePath;
                
                // Step 1: íŒŒì¼ ê²€ì¦
                Application.Current.Dispatcher.Invoke(() =>
                {
                    fileItem.UpdateStep(currentStep, "íŒŒì¼ í˜•ì‹ ê²€ì¦ ì¤‘...", StepStatus.InProgress);
                });
                
                try
                {
                    string extension = System.IO.Path.GetExtension(fileItem.FilePath).ToLower();
                    if (extension != ".pdf" && extension != ".doc" && extension != ".docx")
                    {
                        throw new NotSupportedException("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.");
                    }
                    
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, $"íŒŒì¼ ê²€ì¦ ì™„ë£Œ ({extension})", StepStatus.Completed);
                    });
                    currentStep++;
                    
                    // Step 2: ë¬¸ì„œ ì¤€ë¹„ (Word íŒŒì¼ì¸ ê²½ìš° PDFë¡œ ë³€í™˜)
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "ë¬¸ì„œ ì¤€ë¹„ ì¤‘...", StepStatus.InProgress);
                    });
                    
                    if (extension != ".pdf")
                    {
                        pdfPath = ConvertWordToPdfFile(fileItem.FilePath);
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, "Word â†’ PDF ë³€í™˜ ì™„ë£Œ", StepStatus.Completed);
                        });
                    }
                    else
                    {
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            fileItem.UpdateStep(currentStep, "PDF íŒŒì¼ ì¤€ë¹„ ì™„ë£Œ", StepStatus.Completed);
                        });
                    }
                    currentStep++;
                    
                    // Step 3: PDF ì½ê¸°
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "PDF íŒŒì¼ ì½ëŠ” ì¤‘...", StepStatus.InProgress);
                    });
                      int totalPages = 0;
                    using (var reader = new PdfReader(pdfPath))
                    using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
                    {
                        totalPages = pdfDoc.GetNumberOfPages();
                    }
                    
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, $"PDF ì½ê¸° ì™„ë£Œ ({totalPages}í˜ì´ì§€)", StepStatus.Completed);
                    });
                    currentStep++;
                    
                    // Step 4: ë¶„í•  ì²˜ë¦¬
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "PDF ë¶„í•  ì¤‘...", StepStatus.InProgress);
                    });
                    
                    SplitPdfFile(pdfPath, pageSize, fileItem, totalPages);
                    
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "PDF ë¶„í•  ì™„ë£Œ", StepStatus.Completed);
                    });
                    currentStep++;
                    
                    // Step 5: ì™„ë£Œ
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, "ëª¨ë“  ì‘ì—… ì™„ë£Œ", StepStatus.Completed);
                    });
                }
                catch (Exception ex)
                {
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        fileItem.UpdateStep(currentStep, $"ì˜¤ë¥˜: {ex.Message}", StepStatus.Error);
                    });
                    throw;
                }
            });
        }        private void SplitPdfFile(string pdfPath, int pageSize, FileItem fileItem, int totalPages)
        {            using (var reader = new PdfReader(pdfPath))
            using (var pdfDoc = new iText.Kernel.Pdf.PdfDocument(reader))
            {
                string outputDir = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(pdfPath) ?? "", "output_split");
                
                if (!Directory.Exists(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }
                
                for (int startPage = 1; startPage <= totalPages; startPage += pageSize)
                {
                    int endPage = Math.Min(startPage + pageSize - 1, totalPages);
                    
                    string outputFileName = $"{System.IO.Path.GetFileNameWithoutExtension(pdfPath)}_page{startPage:D2}-{endPage:D2}.pdf";
                    string outputFilePath = System.IO.Path.Combine(outputDir, outputFileName);
                    
                    using (var writer = new iText.Kernel.Pdf.PdfWriter(outputFilePath))
                    using (var newPdfDoc = new iText.Kernel.Pdf.PdfDocument(writer))
                    {
                        pdfDoc.CopyPagesTo(startPage, endPage, newPdfDoc);
                    }
                }
            }
        }

        /// <summary>
        /// Syncfusionì„ ì‚¬ìš©í•˜ì—¬ Word íŒŒì¼ì„ PDFë¡œ ë³€í™˜í•©ë‹ˆë‹¤. (Office ì„¤ì¹˜ ë¶ˆí•„ìš”)
        /// </summary>
        /// <param name="wordFilePath">ë³€í™˜í•  Word íŒŒì¼ ê²½ë¡œ</param>
        /// <returns>ìƒì„±ëœ PDF íŒŒì¼ ê²½ë¡œ</returns>
        private string ConvertWordToPdfFileWithSyncfusion(string wordFilePath)
        {
            try
            {
                LogMessage($"ConvertWordToPdfFileWithSyncfusion ì‹œì‘ - Word: {wordFilePath}");
                
                // íŒŒì¼ ì¡´ì¬ í™•ì¸
                if (!File.Exists(wordFilePath))
                {
                    throw new FileNotFoundException($"Word íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {wordFilePath}");
                }
                
                string outputPath = System.IO.Path.ChangeExtension(wordFilePath, ".pdf");
                LogMessage($"ì˜ˆìƒ ì¶œë ¥ ê²½ë¡œ: {outputPath}");
                
                // ì¶œë ¥ íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ê²½ìš° ë°±ì—… ìƒì„±
                if (File.Exists(outputPath))
                {
                    string backupPath = System.IO.Path.ChangeExtension(outputPath, $".backup_{DateTime.Now:yyyyMMdd_HHmmss}.pdf");
                    File.Move(outputPath, backupPath);
                    LogMessage($"ê¸°ì¡´ PDF íŒŒì¼ì„ ë°±ì—…ìœ¼ë¡œ ì´ë™: {backupPath}");
                }
                
                // Word ë¬¸ì„œ íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì—´ê¸° (ì½ê¸° ì „ìš©, ê³µìœ  ì½ê¸° í—ˆìš©)
                using (FileStream fileStream = new FileStream(wordFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    LogMessage($"Word íŒŒì¼ ìŠ¤íŠ¸ë¦¼ ì—´ê¸° ì„±ê³µ");
                    
                    // ê¸°ì¡´ Word ë¬¸ì„œ ë¡œë“œ
                    using (WordDocument wordDocument = new WordDocument(fileStream, FormatType.Automatic))
                    {
                        LogMessage($"Word ë¬¸ì„œ ë¡œë“œ ì„±ê³µ - ì„¹ì…˜ ìˆ˜: {wordDocument.Sections.Count}");
                        
                        // DocIORenderer ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
                        using (DocIORenderer renderer = new DocIORenderer())
                        {
                            LogMessage($"DocIORenderer ìƒì„± ì„±ê³µ");
                            
                            // Word ë¬¸ì„œë¥¼ PDF ë¬¸ì„œë¡œ ë³€í™˜
                            using (Syncfusion.Pdf.PdfDocument pdfDocument = renderer.ConvertToPDF(wordDocument))
                            {
                                LogMessage($"PDF ë³€í™˜ ì„±ê³µ - í˜ì´ì§€ ìˆ˜: {pdfDocument.Pages.Count}");
                                
                                // PDF íŒŒì¼ì„ íŒŒì¼ ì‹œìŠ¤í…œì— ì €ì¥ (ì“°ê¸° ì „ìš©)
                                using (FileStream outputStream = new FileStream(outputPath, FileMode.Create, FileAccess.Write, FileShare.None))
                                {
                                    pdfDocument.Save(outputStream);
                                    LogMessage($"PDF íŒŒì¼ ì €ì¥ ì„±ê³µ: {outputPath}");
                                }
                            }
                        }
                    }
                }
                
                // íŒŒì¼ì´ ì‹¤ì œë¡œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
                if (File.Exists(outputPath))
                {
                    var fileInfo = new FileInfo(outputPath);
                    LogMessage($"ë³€í™˜ëœ PDF íŒŒì¼ í™•ì¸: {outputPath}, í¬ê¸°: {fileInfo.Length} bytes");
                    
                    // íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ê²½ê³ 
                    if (fileInfo.Length < 1024) // 1KB ë¯¸ë§Œ
                    {
                        LogMessage($"ê²½ê³ : ìƒì„±ëœ PDF íŒŒì¼ í¬ê¸°ê°€ ë§¤ìš° ì‘ìŠµë‹ˆë‹¤ ({fileInfo.Length} bytes). ë‚´ìš©ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.", level: "WARN");
                    }
                }
                else
                {
                    LogMessage($"ë³€í™˜ëœ PDF íŒŒì¼ ìƒì„± ì‹¤íŒ¨: {outputPath}", level: "ERROR");
                    throw new FileNotFoundException($"ë³€í™˜ëœ PDF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {outputPath}");
                }
                
                LogMessage($"ConvertWordToPdfFileWithSyncfusion ì™„ë£Œ - ë°˜í™˜: {outputPath}");
                return outputPath;
            }
            catch (UnauthorizedAccessException ex)
            {
                LogMessage($"íŒŒì¼ ì ‘ê·¼ ê¶Œí•œ ì˜¤ë¥˜: {wordFilePath}", ex, "ERROR");
                string errorMessage = $"íŒŒì¼ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n" +
                                    $"íŒŒì¼: {System.IO.Path.GetFileName(wordFilePath)}\n" +
                                    $"ì˜¤ë¥˜: íŒŒì¼ì´ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš© ì¤‘ì´ê±°ë‚˜ ì½ê¸° ì „ìš©ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n" +
                                    $"í•´ê²° ë°©ë²•:\n" +
                                    $"â€¢ Wordì—ì„œ íŒŒì¼ì„ ë‹«ê³  ë‹¤ì‹œ ì‹œë„\n" +
                                    $"â€¢ íŒŒì¼ì˜ ì½ê¸° ì „ìš© ì†ì„± í•´ì œ\n" +
                                    $"â€¢ ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰";
                
                MessageBox.Show(errorMessage, "íŒŒì¼ ì ‘ê·¼ ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                throw;
            }
            catch (IOException ex)
            {
                LogMessage($"íŒŒì¼ I/O ì˜¤ë¥˜: {wordFilePath}", ex, "ERROR");
                string errorMessage = $"íŒŒì¼ ì½ê¸°/ì“°ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\n" +
                                    $"íŒŒì¼: {System.IO.Path.GetFileName(wordFilePath)}\n" +
                                    $"ì˜¤ë¥˜: {ex.Message}\n\n" +
                                    $"ê°€ëŠ¥í•œ ì›ì¸:\n" +
                                    $"â€¢ ë””ìŠ¤í¬ ê³µê°„ ë¶€ì¡±\n" +
                                    $"â€¢ íŒŒì¼ì´ ì†ìƒë¨\n" +
                                    $"â€¢ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œ (ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë¸Œì˜ ê²½ìš°)";
                
                MessageBox.Show(errorMessage, "íŒŒì¼ I/O ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                throw;
            }
            catch (Exception ex)
            {
                // ë¡œê·¸ íŒŒì¼ì— ì˜¤ë¥˜ ê¸°ë¡
                LogMessage($"Syncfusion Wordâ†’PDF ë³€í™˜ ì‹¤íŒ¨: {wordFilePath}", ex, "ERROR");
                
                // ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
                string errorMessage = $"Word íŒŒì¼ì„ PDFë¡œ ë³€í™˜í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n\n" +
                                    $"íŒŒì¼: {System.IO.Path.GetFileName(wordFilePath)}\n" +
                                    $"ì˜¤ë¥˜: {ex.Message}\n\n" +
                                    $"ê°€ëŠ¥í•œ ì›ì¸:\n" +
                                    $"â€¢ íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ì•”í˜¸ë¡œ ë³´í˜¸ë¨\n" +
                                    $"â€¢ ì§€ì›ë˜ì§€ ì•ŠëŠ” Word ë¬¸ì„œ í˜•ì‹\n" +
                                    $"â€¢ Syncfusion ë¼ì´ì„ ìŠ¤ ë¬¸ì œ\n" +
                                    $"â€¢ ë©”ëª¨ë¦¬ ë¶€ì¡±\n\n" +
                                    $"ìƒì„¸í•œ ì˜¤ë¥˜ ì •ë³´ëŠ” ë¡œê·¸ íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”.";
                
                MessageBox.Show(errorMessage, "Wordâ†’PDF ë³€í™˜ ì˜¤ë¥˜", MessageBoxButton.OK, MessageBoxImage.Error);
                
                throw; // ìƒìœ„ í˜¸ì¶œìì—ê²Œ ì˜ˆì™¸ ì „íŒŒ
            }
        }

        /// <summary>
        /// Word íŒŒì¼ì„ PDFë¡œ ë³€í™˜í•©ë‹ˆë‹¤. (Syncfusion ë°©ì‹ ì‚¬ìš©)
        /// </summary>
        /// <param name="wordFilePath">ë³€í™˜í•  Word íŒŒì¼ ê²½ë¡œ</param>
        /// <returns>ìƒì„±ëœ PDF íŒŒì¼ ê²½ë¡œ</returns>
        private string ConvertWordToPdfFile(string wordFilePath)
        {
            return ConvertWordToPdfFileWithSyncfusion(wordFilePath);
        }

        /// <summary>
        /// ë¡œê·¸ ë©”ì‹œì§€ë¥¼ íŒŒì¼ì— ê¸°ë¡í•©ë‹ˆë‹¤.
        /// </summary>
        /// <param name="message">ë¡œê·¸ ë©”ì‹œì§€</param>
        /// <param name="exception">ì˜ˆì™¸ ê°ì²´ (ì„ íƒì‚¬í•­)</param>
        /// <param name="level">ë¡œê·¸ ë ˆë²¨</param>
        private void LogMessage(string message, Exception? exception = null, string level = "INFO")
        {
            try
            {
                string baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
                string logDirectory = System.IO.Path.Combine(baseDirectory, "logs");
                
                if (!Directory.Exists(logDirectory))
                {
                    Directory.CreateDirectory(logDirectory);
                }
                
                string logFile = System.IO.Path.Combine(logDirectory, $"pdfsplitter-{DateTime.Now:yyyy-MM-dd}.log");
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} [{level}] {message}\n";
                
                if (exception != null)
                {
                    logEntry += $"Exception: {exception.GetType().FullName}: {exception.Message}\n";
                    if (exception.StackTrace != null)
                    {
                        logEntry += $"StackTrace: {exception.StackTrace}\n";
                    }
                    logEntry += "--------------------------------------------------\n";
                }
                
                File.AppendAllText(logFile, logEntry);
            }
            catch
            {
                // ë¡œê¹… ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
            }
        }

        /// <summary>
        /// ì˜¤ë¥˜ë¥¼ ë¡œê·¸ íŒŒì¼ì— ê¸°ë¡í•©ë‹ˆë‹¤. (í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼)
        /// </summary>
        /// <param name="message">ì˜¤ë¥˜ ë©”ì‹œì§€</param>
        /// <param name="exception">ì˜ˆì™¸ ê°ì²´</param>
        private void LogError(string message, Exception exception)
        {
            LogMessage(message, exception, "ERROR");
        }

        #region ë©”ë‰´ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

        private void MenuItem_New_Click(object sender, RoutedEventArgs e)
        {
            // ìƒˆ íŒŒì¼ - í˜„ì¬ íŒŒì¼ ëª©ë¡ ì´ˆê¸°í™”
            fileItems.Clear();
            txtStatus.Text = "âœ… ì¤€ë¹„ë¨";
        }

        private void MenuItem_Open_Click(object sender, RoutedEventArgs e)
        {
            // íŒŒì¼ ì—´ê¸° - ê¸°ì¡´ íŒŒì¼ ì¶”ê°€ ê¸°ëŠ¥ í˜¸ì¶œ
            BtnAddFiles_Click(sender, e);
        }

        private void MenuItem_Save_Click(object sender, RoutedEventArgs e)
        {
            // ì €ì¥ ê¸°ëŠ¥ (í˜„ì¬ êµ¬í˜„í•˜ì§€ ì•ŠìŒ)
            MessageBox.Show("ì €ì¥ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Exit_Click(object sender, RoutedEventArgs e)
        {
            // í”„ë¡œê·¸ë¨ ì¢…ë£Œ
            this.Close();
        }

        private void MenuItem_Undo_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ì‹¤í–‰ ì·¨ì†Œ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Cut_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ì˜ë¼ë‚´ê¸° ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Copy_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ë³µì‚¬ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_Paste_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show("ë¶™ì—¬ë„£ê¸° ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.", "ì •ë³´", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void MenuItem_FontSize_Click(object sender, RoutedEventArgs e)
        {
            if (sender is MenuItem menuItem && menuItem.Tag is string fontSizeStr)
            {
                if (double.TryParse(fontSizeStr, out double fontSize))
                {
                    // Windowì˜ FontSizeë¥¼ ë³€ê²½í•˜ì—¬ ëª¨ë“  ì»¨íŠ¸ë¡¤ì— ìƒì†
                    this.FontSize = fontSize;
                    
                    // ë©”ë‰´ ì²´í¬ ìƒíƒœ ì—…ë°ì´íŠ¸
                    UpdateFontSizeMenuItems(fontSize);
                }
            }
        }

        private void UpdateFontSizeMenuItems(double currentFontSize)
        {
            // ë©”ë‰´ ì°¾ê¸° - Gridì—ì„œ Menu ì°¾ê¸°
            if (this.Content is Grid grid)
            {
                var menu = FindVisualChild<Menu>(grid);
                if (menu != null)
                {
                    var optionsMenu = menu.Items.OfType<MenuItem>().FirstOrDefault(m => m.Header.ToString() == "Options");
                    if (optionsMenu != null)
                    {
                        var fontSizeMenu = optionsMenu.Items.OfType<MenuItem>().FirstOrDefault(m => m.Header.ToString() == "Font Size");
                        if (fontSizeMenu != null)
                        {
                            // ëª¨ë“  í•˜ìœ„ ë©”ë‰´ ì•„ì´í…œì˜ ì²´í¬ í•´ì œ
                            foreach (MenuItem item in fontSizeMenu.Items.OfType<MenuItem>())
                            {
                                item.IsChecked = false;
                            }

                            // í˜„ì¬ ì„ íƒëœ í¬ê¸°ì˜ ë©”ë‰´ ì•„ì´í…œ ì²´í¬
                            var targetMenuItem = fontSizeMenu.Items.OfType<MenuItem>()
                                .FirstOrDefault(m => m.Tag?.ToString() == currentFontSize.ToString());
                            if (targetMenuItem != null)
                            {
                                targetMenuItem.IsChecked = true;
                            }
                        }
                    }
                }
            }
        }        private T? FindVisualChild<T>(DependencyObject parent) where T : DependencyObject
        {
            for (int i = 0; i < VisualTreeHelper.GetChildren